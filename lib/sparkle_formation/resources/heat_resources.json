{
  "OS::Aodh::CompositeAlarm": {
    "full_properties": {
      "alarm_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "alarm_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "composite_rule": {
        "description": "Composite threshold rules in JSON format.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "True if alarm evaluation/actioning is enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "insufficient_data_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "insufficient_data_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "repeat_actions": {
        "description": "False to trigger actions when the threshold is reached AND the alarm’s state has changed. By default, actions are called each time the threshold is reached.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "time_constraints": {
        "description": "Describe time constraints for the alarm. Only evaluate the alarm if the time at evaluation is within this time constraint. Start point(s) of the constraint are specified with a cron expression, whereas its duration is given in seconds.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "alarm_actions",
      "alarm_queues",
      "composite_rule",
      "description",
      "enabled",
      "insufficient_data_actions",
      "insufficient_data_queues",
      "ok_actions",
      "ok_queues",
      "repeat_actions",
      "severity",
      "time_constraints"
    ]
  },
  "OS::Aodh::EventAlarm": {
    "full_properties": {
      "alarm_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "alarm_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "True if alarm evaluation/actioning is enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "event_type": {
        "description": "Event type to evaluate against. If not specified will match all events.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "insufficient_data_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "insufficient_data_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "query": {
        "description": "A list for filtering events. Query conditions used to filter specific events when evaluating the alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "repeat_actions": {
        "description": "False to trigger actions when the threshold is reached AND the alarm’s state has changed. By default, actions are called each time the threshold is reached.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "time_constraints": {
        "description": "Describe time constraints for the alarm. Only evaluate the alarm if the time at evaluation is within this time constraint. Start point(s) of the constraint are specified with a cron expression, whereas its duration is given in seconds.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "alarm_actions",
      "alarm_queues",
      "description",
      "enabled",
      "event_type",
      "insufficient_data_actions",
      "insufficient_data_queues",
      "ok_actions",
      "ok_queues",
      "query",
      "repeat_actions",
      "severity",
      "time_constraints"
    ]
  },
  "OS::Aodh::GnocchiAggregationByMetricsAlarm": {
    "full_properties": {
      "aggregation_method": {
        "description": "The aggregation method to compare to the threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "alarm_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "alarm_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "comparison_operator": {
        "description": "Operator used to compare specified statistic with threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "True if alarm evaluation/actioning is enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "evaluation_periods": {
        "description": "Number of periods to evaluate over.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "granularity": {
        "description": "The time range in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "insufficient_data_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "insufficient_data_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "metrics": {
        "description": "A list of metric ids.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "repeat_actions": {
        "description": "False to trigger actions when the threshold is reached AND the alarm’s state has changed. By default, actions are called each time the threshold is reached.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "threshold": {
        "description": "Threshold to evaluate against.",
        "required": true,
        "type": "number",
        "update_causes": "none"
      },
      "time_constraints": {
        "description": "Describe time constraints for the alarm. Only evaluate the alarm if the time at evaluation is within this time constraint. Start point(s) of the constraint are specified with a cron expression, whereas its duration is given in seconds.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "aggregation_method",
      "alarm_actions",
      "alarm_queues",
      "comparison_operator",
      "description",
      "enabled",
      "evaluation_periods",
      "granularity",
      "insufficient_data_actions",
      "insufficient_data_queues",
      "metrics",
      "ok_actions",
      "ok_queues",
      "repeat_actions",
      "severity",
      "threshold",
      "time_constraints"
    ]
  },
  "OS::Aodh::GnocchiAggregationByResourcesAlarm": {
    "full_properties": {
      "aggregation_method": {
        "description": "The aggregation method to compare to the threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "alarm_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "alarm_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "comparison_operator": {
        "description": "Operator used to compare specified statistic with threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "True if alarm evaluation/actioning is enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "evaluation_periods": {
        "description": "Number of periods to evaluate over.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "granularity": {
        "description": "The time range in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "insufficient_data_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "insufficient_data_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "metric": {
        "description": "Metric name watched by the alarm.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "query": {
        "description": "The query to filter the metrics.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "repeat_actions": {
        "description": "False to trigger actions when the threshold is reached AND the alarm’s state has changed. By default, actions are called each time the threshold is reached.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "resource_type": {
        "description": "Resource type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "threshold": {
        "description": "Threshold to evaluate against.",
        "required": true,
        "type": "number",
        "update_causes": "none"
      },
      "time_constraints": {
        "description": "Describe time constraints for the alarm. Only evaluate the alarm if the time at evaluation is within this time constraint. Start point(s) of the constraint are specified with a cron expression, whereas its duration is given in seconds.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "aggregation_method",
      "alarm_actions",
      "alarm_queues",
      "comparison_operator",
      "description",
      "enabled",
      "evaluation_periods",
      "granularity",
      "insufficient_data_actions",
      "insufficient_data_queues",
      "metric",
      "ok_actions",
      "ok_queues",
      "query",
      "repeat_actions",
      "resource_type",
      "severity",
      "threshold",
      "time_constraints"
    ]
  },
  "OS::Aodh::GnocchiResourcesAlarm": {
    "full_properties": {
      "aggregation_method": {
        "description": "The aggregation method to compare to the threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "alarm_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "alarm_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to alarm.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "comparison_operator": {
        "description": "Operator used to compare specified statistic with threshold.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "True if alarm evaluation/actioning is enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "evaluation_periods": {
        "description": "Number of periods to evaluate over.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "granularity": {
        "description": "The time range in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "insufficient_data_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "insufficient_data_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to insufficient-data.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "metric": {
        "description": "Metric name watched by the alarm.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "A list of URLs (webhooks) to invoke when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ok_queues": {
        "description": "A list of Zaqar queues to post to when state transitions to ok.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "repeat_actions": {
        "description": "False to trigger actions when the threshold is reached AND the alarm’s state has changed. By default, actions are called each time the threshold is reached.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "resource_id": {
        "description": "Id of a resource.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "resource_type": {
        "description": "Resource type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "threshold": {
        "description": "Threshold to evaluate against.",
        "required": true,
        "type": "number",
        "update_causes": "none"
      },
      "time_constraints": {
        "description": "Describe time constraints for the alarm. Only evaluate the alarm if the time at evaluation is within this time constraint. Start point(s) of the constraint are specified with a cron expression, whereas its duration is given in seconds.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "aggregation_method",
      "alarm_actions",
      "alarm_queues",
      "comparison_operator",
      "description",
      "enabled",
      "evaluation_periods",
      "granularity",
      "insufficient_data_actions",
      "insufficient_data_queues",
      "metric",
      "ok_actions",
      "ok_queues",
      "repeat_actions",
      "resource_id",
      "resource_type",
      "severity",
      "threshold",
      "time_constraints"
    ]
  },
  "OS::Barbican::CertificateContainer": {
    "full_properties": {
      "certificate_ref": {
        "description": "Reference to certificate.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "intermediates_ref": {
        "description": "Reference to intermediates.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Human-readable name for the container.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "private_key_passphrase_ref": {
        "description": "Reference to private key passphrase.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "private_key_ref": {
        "description": "Reference to private key.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "certificate_ref",
      "intermediates_ref",
      "name",
      "private_key_passphrase_ref",
      "private_key_ref"
    ]
  },
  "OS::Barbican::GenericContainer": {
    "full_properties": {
      "name": {
        "description": "Human-readable name for the container.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "secrets": {
        "description": "References to secrets that will be stored in container.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "name",
      "secrets"
    ]
  },
  "OS::Barbican::Order": {
    "full_properties": {
      "algorithm": {
        "description": "The algorithm type used to generate the secret. Required for key and asymmetric types of order.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "bit_length": {
        "description": "The bit-length of the secret. Required for key and asymmetric types of order.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "ca_id": {
        "description": "The identifier of the CA to use.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "expiration": {
        "description": "The expiration date for the secret in ISO-8601 format.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "mode": {
        "description": "The type/mode of the algorithm associated with the secret information.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Human readable name for the secret.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "pass_phrase": {
        "description": "The passphrase of the created key. Can be set only for asymmetric type of order.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "payload_content_type": {
        "description": "The type/format the secret data is provided in.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "profile": {
        "description": "The profile of certificate to use.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "request_data": {
        "description": "The content of the CSR. Only for certificate orders.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "request_type": {
        "description": "The type of the certificate request.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "source_container_ref": {
        "description": "The source of certificate request.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "subject_dn": {
        "description": "The subject of the certificate request.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "type": {
        "description": "The type of the order.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "algorithm",
      "bit_length",
      "ca_id",
      "expiration",
      "mode",
      "name",
      "pass_phrase",
      "payload_content_type",
      "profile",
      "request_data",
      "request_type",
      "source_container_ref",
      "subject_dn",
      "type"
    ]
  },
  "OS::Barbican::RSAContainer": {
    "full_properties": {
      "name": {
        "description": "Human-readable name for the container.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "private_key_passphrase_ref": {
        "description": "Reference to private key passphrase.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "private_key_ref": {
        "description": "Reference to private key.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "public_key_ref": {
        "description": "Reference to public key.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "name",
      "private_key_passphrase_ref",
      "private_key_ref",
      "public_key_ref"
    ]
  },
  "OS::Barbican::Secret": {
    "full_properties": {
      "algorithm": {
        "description": "The algorithm type used to generate the secret.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "bit_length": {
        "description": "The bit-length of the secret.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "expiration": {
        "description": "The expiration date for the secret in ISO-8601 format.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "mode": {
        "description": "The type/mode of the algorithm associated with the secret information.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Human readable name for the secret.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "payload": {
        "description": "The unencrypted plain text of the secret.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "payload_content_encoding": {
        "description": "The encoding format used to provide the payload data.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "payload_content_type": {
        "description": "The type/format the secret data is provided in.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "secret_type": {
        "description": "The type of the secret.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "algorithm",
      "bit_length",
      "expiration",
      "mode",
      "name",
      "payload",
      "payload_content_encoding",
      "payload_content_type",
      "secret_type"
    ]
  },
  "OS::Cinder::EncryptedVolumeType": {
    "full_properties": {
      "cipher": {
        "description": "The encryption algorithm or mode. For example, aes-xts-plain64.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "control_location": {
        "description": "Notional service where encryption is performed For example, front-end. For Nova.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "key_size": {
        "description": "Size of encryption key, in bits. For example, 128 or 256.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "provider": {
        "description": "The class that provides encryption support. For example, nova.volume.encryptors.luks.LuksEncryptor.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "volume_type": {
        "description": "Name or id of volume type (OS::Cinder::VolumeType).",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "cipher",
      "control_location",
      "key_size",
      "provider",
      "volume_type"
    ]
  },
  "OS::Cinder::QoSAssociation": {
    "full_properties": {
      "qos_specs": {
        "description": "ID or Name of the QoS specs.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "volume_types": {
        "description": "List of volume type IDs or Names to be attached to QoS specs.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "qos_specs",
      "volume_types"
    ]
  },
  "OS::Cinder::QoSSpecs": {
    "full_properties": {
      "name": {
        "description": "Name of the QoS.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "specs": {
        "description": "The specs key and value pairs of the QoS.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "name",
      "specs"
    ]
  },
  "OS::Cinder::Quota": {
    "full_properties": {
      "gigabytes": {
        "description": "Quota for the amount of disk space (in Gigabytes). Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "project": {
        "description": "OpenStack Keystone Project.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "snapshots": {
        "description": "Quota for the number of snapshots. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "volumes": {
        "description": "Quota for the number of volumes. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "gigabytes",
      "project",
      "snapshots",
      "volumes"
    ]
  },
  "OS::Cinder::Volume": {
    "full_properties": {
      "availability_zone": {
        "description": "The availability zone in which the volume will be created.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "backup_id": {
        "description": "If specified, the backup to create the volume from.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "A description of the volume.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "image": {
        "description": "If specified, the name or ID of the image to create the volume from.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "metadata": {
        "description": "Key/value pairs to associate with the volume.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "multiattach": {
        "description": "Whether allow the volume to be attached more than once.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "name": {
        "description": "A name used to distinguish the volume.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "read_only": {
        "description": "Enables or disables read-only access mode of volume.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "scheduler_hints": {
        "description": "Arbitrary key-value pairs specified by the client to help the Cinder scheduler creating a volume.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "size": {
        "description": "The size of the volume in GB. On update only increase in size is supported. This property is required unless property backup_id or source_volid or snapshot_id is specified.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "snapshot_id": {
        "description": "If specified, the snapshot to create the volume from.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "source_volid": {
        "description": "If specified, the volume to use as source.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "volume_type": {
        "description": "If specified, the type of volume to use, mapping to a specific backend.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "availability_zone",
      "backup_id",
      "description",
      "image",
      "metadata",
      "multiattach",
      "name",
      "read_only",
      "scheduler_hints",
      "size",
      "snapshot_id",
      "source_volid",
      "volume_type"
    ]
  },
  "OS::Cinder::VolumeAttachment": {
    "full_properties": {
      "instance_uuid": {
        "description": "The ID of the server to which the volume attaches.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "mountpoint": {
        "description": "The location where the volume is exposed on the instance. This assignment may not be honored and it is advised that the path /dev/disk/by-id/virtio-<VolumeId> be used instead.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "volume_id": {
        "description": "The ID of the volume to be attached.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "instance_uuid",
      "mountpoint",
      "volume_id"
    ]
  },
  "OS::Cinder::VolumeType": {
    "full_properties": {
      "description": {
        "description": "Description of the volume type.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "is_public": {
        "description": "Whether the volume type is accessible to the public.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "metadata": {
        "description": "The extra specs key and value pairs of the volume type.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the volume type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "projects": {
        "description": "Projects to add volume type access to. NOTE: This property is only supported since Cinder API V2.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "is_public",
      "metadata",
      "name",
      "projects"
    ]
  },
  "OS::Designate::RecordSet": {
    "full_properties": {
      "description": {
        "description": "Description of RecordSet.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "RecordSet name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "records": {
        "description": "A list of data for this RecordSet. Each item will be a separate record in Designate These items should conform to the DNS spec for the record type - e.g. A records must be IPv4 addresses, CNAME records must be a hostname. DNS record data varies based on the type of record. For more details, please refer rfc 1035.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "ttl": {
        "description": "Time To Live (Seconds).",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "type": {
        "description": "DNS RecordSet type.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "zone": {
        "description": "DNS Zone id or name.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "name",
      "records",
      "ttl",
      "type",
      "zone"
    ]
  },
  "OS::Designate::Zone": {
    "full_properties": {
      "description": {
        "description": "Description of zone.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "email": {
        "description": "E-mail for the zone. Used in SOA records for the zone. It is required for PRIMARY Type, otherwise ignored.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "masters": {
        "description": "The servers to slave from to get DNS information and is mandatory for zone type SECONDARY, otherwise ignored.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "DNS Name for the zone.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "ttl": {
        "description": "Time To Live (Seconds) for the zone.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "type": {
        "description": "Type of zone. PRIMARY is controlled by Designate, SECONDARY zones are slaved from another DNS Server.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "email",
      "masters",
      "name",
      "ttl",
      "type"
    ]
  },
  "OS::Heat::AccessPolicy": {
    "full_properties": {
      "AllowedResources": {
        "description": "Resources that users are allowed to access by the DescribeStackResource API.",
        "required": true,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "AllowedResources"
    ]
  },
  "OS::Heat::AutoScalingGroup": {
    "full_properties": {
      "cooldown": {
        "description": "Cooldown period, in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "desired_capacity": {
        "description": "Desired initial number of resources.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "max_size": {
        "description": "Maximum number of resources in the group.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "min_size": {
        "description": "Minimum number of resources in the group.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "resource": {
        "description": "Resource definition for the resources in the group, in HOT format. The value of this property is the definition of a resource just as if it had been declared in the template itself.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      },
      "rolling_updates": {
        "description": "Policy for rolling updates for this scaling group.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "cooldown",
      "desired_capacity",
      "max_size",
      "min_size",
      "resource",
      "rolling_updates"
    ]
  },
  "OS::Heat::CloudConfig": {
    "full_properties": {
      "cloud_config": {
        "description": "Map representing the cloud-config data structure which will be formatted as YAML.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "cloud_config"
    ]
  },
  "OS::Heat::DeployedServer": {
    "full_properties": {
      "deployment_swift_data": {
        "description": "Swift container and object to use for storing deployment data for the server resource. The parameter is a map value with the keys “container” and “object”, and the values are the corresponding container and object names. The software_config_transport parameter must be set to POLL_TEMP_URL for swift to be used. If not specified, and software_config_transport is set to POLL_TEMP_URL, a container will be automatically created from the resource name, and the object name will be a generated uuid.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "metadata": {
        "description": "Arbitrary key/value metadata to store for this server. Both keys and values must be 255 characters or less. Non-string values will be serialized to JSON (and the serialized string must be 255 characters or less).",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Server name.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "software_config_transport": {
        "description": "How the server should receive the metadata required for software configuration. POLL_SERVER_CFN will allow calls to the cfn API action DescribeStackResource authenticated with the provided keypair. POLL_SERVER_HEAT will allow calls to the Heat API resource-show using the provided keystone credentials. POLL_TEMP_URL will create and populate a Swift TempURL with metadata for polling. ZAQAR_MESSAGE will create a dedicated zaqar queue and post the metadata for polling.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "deployment_swift_data",
      "metadata",
      "name",
      "software_config_transport"
    ]
  },
  "OS::Heat::InstanceGroup": {
    "full_properties": {
      "AvailabilityZones": {
        "description": "Not Implemented.",
        "required": true,
        "type": "list",
        "update_causes": "replacement"
      },
      "LaunchConfigurationName": {
        "description": "The reference to a LaunchConfiguration resource.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "LoadBalancerNames": {
        "description": "List of LoadBalancer resources.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "Size": {
        "description": "Desired number of instances.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "Tags": {
        "description": "Tags to attach to this group.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "AvailabilityZones",
      "LaunchConfigurationName",
      "LoadBalancerNames",
      "Size",
      "Tags"
    ]
  },
  "OS::Heat::MultipartMime": {
    "full_properties": {
      "parts": {
        "description": "Parts belonging to this message.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "parts"
    ]
  },
  "OS::Heat::None": {
    "full_properties": {
    },
    "properties": [

    ]
  },
  "OS::Heat::RandomString": {
    "full_properties": {
      "character_classes": {
        "description": "A list of character class and their constraints to generate the random string from.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "character_sequences": {
        "description": "A list of character sequences and their constraints to generate the random string from.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "length": {
        "description": "Length of the string to generate.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "salt": {
        "description": "Value which can be set or changed on stack update to trigger the resource for replacement with a new random string. The salt value itself is ignored by the random generator.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "character_classes",
      "character_sequences",
      "length",
      "salt"
    ]
  },
  "OS::Heat::ResourceChain": {
    "full_properties": {
      "concurrent": {
        "description": "If true, the resources in the chain will be created concurrently. If false or omitted, each resource will be treated as having a dependency on the previous resource in the list.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "resource_properties": {
        "description": "Properties to pass to each resource being created in the chain.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "resources": {
        "description": "The list of resource types to create. This list may contain type names or aliases defined in the resource registry. Specific template names are not supported.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "concurrent",
      "resource_properties",
      "resources"
    ]
  },
  "OS::Heat::ResourceGroup": {
    "full_properties": {
      "count": {
        "description": "The number of resources to create.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "index_var": {
        "description": "A variable that this resource will use to replace with the current index of a given resource in the group. Can be used, for example, to customize the name property of grouped servers in order to differentiate them when listed with nova client.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "removal_policies": {
        "description": "Policies for removal of resources on update.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "removal_policies_mode": {
        "description": "How to handle changes to removal_policies on update. The default “append” mode appends to the internal list, “update” replaces it on update.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "resource_def": {
        "description": "Resource definition for the resources in the group. The value of this property is the definition of a resource just as if it had been declared in the template itself.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "count",
      "index_var",
      "removal_policies",
      "removal_policies_mode",
      "resource_def"
    ]
  },
  "OS::Heat::ScalingPolicy": {
    "full_properties": {
      "adjustment_type": {
        "description": "Type of adjustment (absolute or percentage).",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "auto_scaling_group_id": {
        "description": "AutoScaling group ID to apply policy to.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "cooldown": {
        "description": "Cooldown period, in seconds.",
        "required": false,
        "type": "number",
        "update_causes": "none"
      },
      "min_adjustment_step": {
        "description": "Minimum number of resources that are added or removed when the AutoScaling group scales up or down. This can be used only when specifying percent_change_in_capacity for the adjustment_type property.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "scaling_adjustment": {
        "description": "Size of adjustment.",
        "required": true,
        "type": "number",
        "update_causes": "none"
      }
    },
    "properties": [
      "adjustment_type",
      "auto_scaling_group_id",
      "cooldown",
      "min_adjustment_step",
      "scaling_adjustment"
    ]
  },
  "OS::Heat::SoftwareComponent": {
    "full_properties": {
      "configs": {
        "description": "The list of configurations for the different lifecycle actions of the represented software component.",
        "required": true,
        "type": "list",
        "update_causes": "replacement"
      },
      "inputs": {
        "description": "Schema representing the inputs that this software config is expecting.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "options": {
        "description": "Map containing options specific to the configuration management tool used by this resource.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "outputs": {
        "description": "Schema representing the outputs that this software config will produce.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "configs",
      "inputs",
      "options",
      "outputs"
    ]
  },
  "OS::Heat::SoftwareConfig": {
    "full_properties": {
      "config": {
        "description": "Configuration script or manifest which specifies what actual configuration is performed.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "group": {
        "description": "Namespace to group this software config by when delivered to a server. This may imply what configuration tool is going to perform the configuration.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "inputs": {
        "description": "Schema representing the inputs that this software config is expecting.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "options": {
        "description": "Map containing options specific to the configuration management tool used by this resource.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "outputs": {
        "description": "Schema representing the outputs that this software config will produce.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "config",
      "group",
      "inputs",
      "options",
      "outputs"
    ]
  },
  "OS::Heat::SoftwareDeployment": {
    "full_properties": {
      "actions": {
        "description": "Which lifecycle actions of the deployment resource will result in this deployment being triggered.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "config": {
        "description": "ID of software configuration resource to execute when applying to the server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "input_values": {
        "description": "Input values to apply to the software configuration on this server.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the derived config associated with this deployment. This is used to apply a sort order to the list of configurations currently deployed to a server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "server": {
        "description": "ID of resource to apply configuration to. Normally this should be a Nova server ID.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "signal_transport": {
        "description": "How the server should signal to heat with the deployment output values. CFN_SIGNAL will allow an HTTP POST to a CFN keypair signed URL. TEMP_URL_SIGNAL will create a Swift TempURL to be signaled via HTTP PUT. HEAT_SIGNAL will allow calls to the Heat API resource-signal using the provided keystone credentials. ZAQAR_SIGNAL will create a dedicated zaqar queue to be signaled using the provided keystone credentials. NO_SIGNAL will result in the resource going to the COMPLETE state without waiting for any signal.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "actions",
      "config",
      "input_values",
      "name",
      "server",
      "signal_transport"
    ]
  },
  "OS::Heat::SoftwareDeploymentGroup": {
    "full_properties": {
      "actions": {
        "description": "Which lifecycle actions of the deployment resource will result in this deployment being triggered.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "config": {
        "description": "ID of software configuration resource to execute when applying to the server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "input_values": {
        "description": "Input values to apply to the software configuration on this server.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the derived config associated with this deployment. This is used to apply a sort order to the list of configurations currently deployed to a server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "servers": {
        "description": "A map of names and server IDs to apply configuration to. The name is arbitrary and is used as the Heat resource name for the corresponding deployment.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      },
      "signal_transport": {
        "description": "How the server should signal to heat with the deployment output values. CFN_SIGNAL will allow an HTTP POST to a CFN keypair signed URL. TEMP_URL_SIGNAL will create a Swift TempURL to be signaled via HTTP PUT. HEAT_SIGNAL will allow calls to the Heat API resource-signal using the provided keystone credentials. ZAQAR_SIGNAL will create a dedicated zaqar queue to be signaled using the provided keystone credentials. NO_SIGNAL will result in the resource going to the COMPLETE state without waiting for any signal.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "actions",
      "config",
      "input_values",
      "name",
      "servers",
      "signal_transport"
    ]
  },
  "OS::Heat::Stack": {
    "full_properties": {
      "context": {
        "description": "Context for this stack.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "parameters": {
        "description": "Set of parameters passed to this stack.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "template": {
        "description": "Template that specifies the stack to be created as a resource.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "timeout": {
        "description": "Number of minutes to wait for this stack creation.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "context",
      "parameters",
      "template",
      "timeout"
    ]
  },
  "OS::Heat::StructuredConfig": {
    "full_properties": {
      "config": {
        "description": "Map representing the configuration data structure which will be serialized to JSON format.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "group": {
        "description": "Namespace to group this software config by when delivered to a server. This may imply what configuration tool is going to perform the configuration.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "inputs": {
        "description": "Schema representing the inputs that this software config is expecting.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "options": {
        "description": "Map containing options specific to the configuration management tool used by this resource.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "outputs": {
        "description": "Schema representing the outputs that this software config will produce.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "config",
      "group",
      "inputs",
      "options",
      "outputs"
    ]
  },
  "OS::Heat::StructuredDeployment": {
    "full_properties": {
      "actions": {
        "description": "Which lifecycle actions of the deployment resource will result in this deployment being triggered.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "config": {
        "description": "ID of software configuration resource to execute when applying to the server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "input_key": {
        "description": "Name of key to use for substituting inputs during deployment.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "input_values": {
        "description": "Input values to apply to the software configuration on this server.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "input_values_validate": {
        "description": "Perform a check on the input values passed to verify that each required input has a corresponding value. When the property is set to STRICT and no value is passed, an exception is raised.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the derived config associated with this deployment. This is used to apply a sort order to the list of configurations currently deployed to a server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "server": {
        "description": "ID of resource to apply configuration to. Normally this should be a Nova server ID.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "signal_transport": {
        "description": "How the server should signal to heat with the deployment output values. CFN_SIGNAL will allow an HTTP POST to a CFN keypair signed URL. TEMP_URL_SIGNAL will create a Swift TempURL to be signaled via HTTP PUT. HEAT_SIGNAL will allow calls to the Heat API resource-signal using the provided keystone credentials. ZAQAR_SIGNAL will create a dedicated zaqar queue to be signaled using the provided keystone credentials. NO_SIGNAL will result in the resource going to the COMPLETE state without waiting for any signal.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "actions",
      "config",
      "input_key",
      "input_values",
      "input_values_validate",
      "name",
      "server",
      "signal_transport"
    ]
  },
  "OS::Heat::StructuredDeploymentGroup": {
    "full_properties": {
      "actions": {
        "description": "Which lifecycle actions of the deployment resource will result in this deployment being triggered.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "config": {
        "description": "ID of software configuration resource to execute when applying to the server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "input_key": {
        "description": "Name of key to use for substituting inputs during deployment.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "input_values": {
        "description": "Input values to apply to the software configuration on this server.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "input_values_validate": {
        "description": "Perform a check on the input values passed to verify that each required input has a corresponding value. When the property is set to STRICT and no value is passed, an exception is raised.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the derived config associated with this deployment. This is used to apply a sort order to the list of configurations currently deployed to a server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "servers": {
        "description": "A map of names and server IDs to apply configuration to. The name is arbitrary and is used as the Heat resource name for the corresponding deployment.",
        "required": true,
        "type": "map",
        "update_causes": "none"
      },
      "signal_transport": {
        "description": "How the server should signal to heat with the deployment output values. CFN_SIGNAL will allow an HTTP POST to a CFN keypair signed URL. TEMP_URL_SIGNAL will create a Swift TempURL to be signaled via HTTP PUT. HEAT_SIGNAL will allow calls to the Heat API resource-signal using the provided keystone credentials. ZAQAR_SIGNAL will create a dedicated zaqar queue to be signaled using the provided keystone credentials. NO_SIGNAL will result in the resource going to the COMPLETE state without waiting for any signal.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "actions",
      "config",
      "input_key",
      "input_values",
      "input_values_validate",
      "name",
      "servers",
      "signal_transport"
    ]
  },
  "OS::Heat::SwiftSignal": {
    "full_properties": {
      "count": {
        "description": "The number of success signals that must be received before the stack creation process continues.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "handle": {
        "description": "URL of TempURL where resource will signal completion and optionally upload data.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "timeout": {
        "description": "The maximum number of seconds to wait for the resource to signal completion. Once the timeout is reached, creation of the signal resource will fail.",
        "required": true,
        "type": "number",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "count",
      "handle",
      "timeout"
    ]
  },
  "OS::Heat::SwiftSignalHandle": {
    "full_properties": {
    },
    "properties": [

    ]
  },
  "OS::Heat::TestResource": {
    "full_properties": {
      "action_wait_secs": {
        "description": "Options for simulating waiting.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "attr_wait_secs": {
        "description": "Number value for timeout during resolving output value.",
        "required": false,
        "type": "number",
        "update_causes": "none"
      },
      "client_name": {
        "description": "Client to poll.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "constraint_prop_secs": {
        "description": "Number value for delay during resolve constraint.",
        "required": false,
        "type": "number",
        "update_causes": "none"
      },
      "entity_name": {
        "description": "Client entity to poll.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "fail": {
        "description": "Value which can be set to fail the resource operation to test failure scenarios.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "update_replace": {
        "description": "Value which can be set to trigger update replace for the particular resource.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "update_replace_value": {
        "description": "Some value that can be stored but can not be updated.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "value": {
        "description": "The input string to be stored.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "wait_secs": {
        "description": "Seconds to wait after an action (-1 is infinite).",
        "required": false,
        "type": "number",
        "update_causes": "none"
      }
    },
    "properties": [
      "action_wait_secs",
      "attr_wait_secs",
      "client_name",
      "constraint_prop_secs",
      "entity_name",
      "fail",
      "update_replace",
      "update_replace_value",
      "value",
      "wait_secs"
    ]
  },
  "OS::Heat::UpdateWaitConditionHandle": {
    "full_properties": {
    },
    "properties": [

    ]
  },
  "OS::Heat::Value": {
    "full_properties": {
      "type": {
        "description": "The type of the “value” property.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "value": {
        "description": "The expression to generate the “value” attribute.",
        "required": true,
        "type": "any",
        "update_causes": "none"
      }
    },
    "properties": [
      "type",
      "value"
    ]
  },
  "OS::Heat::WaitCondition": {
    "full_properties": {
      "count": {
        "description": "The number of success signals that must be received before the stack creation process continues.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "handle": {
        "description": "A reference to the wait condition handle used to signal this wait condition.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "timeout": {
        "description": "The number of seconds to wait for the correct number of signals to arrive.",
        "required": true,
        "type": "number",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "count",
      "handle",
      "timeout"
    ]
  },
  "OS::Heat::WaitConditionHandle": {
    "full_properties": {
      "signal_transport": {
        "description": "How the client will signal the wait condition. CFN_SIGNAL will allow an HTTP POST to a CFN keypair signed URL. TEMP_URL_SIGNAL will create a Swift TempURL to be signalled via HTTP PUT. HEAT_SIGNAL will allow calls to the Heat API resource-signal using the provided keystone credentials. ZAQAR_SIGNAL will create a dedicated zaqar queue to be signalled using the provided keystone credentials. TOKEN_SIGNAL will allow and HTTP POST to a Heat API endpoint with the provided keystone token. NO_SIGNAL will result in the resource going to a signalled state without waiting for any signal.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "signal_transport"
    ]
  },
  "OS::Keystone::Domain": {
    "full_properties": {
      "description": {
        "description": "Description of keystone domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "This domain is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "name": {
        "description": "The name of the domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "enabled",
      "name"
    ]
  },
  "OS::Keystone::Endpoint": {
    "full_properties": {
      "enabled": {
        "description": "This endpoint is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "interface": {
        "description": "Interface type of keystone service endpoint.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of keystone endpoint.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "region": {
        "description": "Name or Id of keystone region.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "service": {
        "description": "Name or Id of keystone service.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "url": {
        "description": "URL of keystone service endpoint.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "enabled",
      "interface",
      "name",
      "region",
      "service",
      "url"
    ]
  },
  "OS::Keystone::Group": {
    "full_properties": {
      "description": {
        "description": "Description of keystone group.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "domain": {
        "description": "Name or id of keystone domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of keystone group.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "roles": {
        "description": "List of role assignments.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "domain",
      "name",
      "roles"
    ]
  },
  "OS::Keystone::GroupRoleAssignment": {
    "full_properties": {
      "group": {
        "description": "Name or id of keystone group.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "roles": {
        "description": "List of role assignments.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "group",
      "roles"
    ]
  },
  "OS::Keystone::Project": {
    "full_properties": {
      "description": {
        "description": "Description of keystone project.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "domain": {
        "description": "Name or id of keystone domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "This project is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of keystone project.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "parent": {
        "description": "The name or ID of parent of this keystone project in hierarchy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "tags": {
        "description": "A list of tags for labeling and sorting projects.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "domain",
      "enabled",
      "name",
      "parent",
      "tags"
    ]
  },
  "OS::Keystone::Region": {
    "full_properties": {
      "description": {
        "description": "Description of keystone region.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "This region is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "id": {
        "description": "The user-defined region ID and should unique to the OpenStack deployment. While creating the region, heat will url encode this ID.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "parent_region": {
        "description": "If the region is hierarchically a child of another region, set this parameter to the ID of the parent region.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "enabled",
      "id",
      "parent_region"
    ]
  },
  "OS::Keystone::Role": {
    "full_properties": {
      "domain": {
        "description": "Name or id of keystone domain.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of keystone role.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "domain",
      "name"
    ]
  },
  "OS::Keystone::Service": {
    "full_properties": {
      "description": {
        "description": "Description of keystone service.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "This service is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of keystone service.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "type": {
        "description": "Type of keystone Service.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "enabled",
      "name",
      "type"
    ]
  },
  "OS::Keystone::User": {
    "full_properties": {
      "default_project": {
        "description": "Name or ID of default project of keystone user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of keystone user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "domain": {
        "description": "Name or ID of keystone domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "email": {
        "description": "Email address of keystone user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "Keystone user is enabled or disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "groups": {
        "description": "Keystone user groups.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of keystone user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "password": {
        "description": "Password of keystone user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "roles": {
        "description": "List of role assignments.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "default_project",
      "description",
      "domain",
      "email",
      "enabled",
      "groups",
      "name",
      "password",
      "roles"
    ]
  },
  "OS::Keystone::UserRoleAssignment": {
    "full_properties": {
      "roles": {
        "description": "List of role assignments.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "user": {
        "description": "Name or id of keystone user.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "roles",
      "user"
    ]
  },
  "OS::Magnum::Cluster": {
    "full_properties": {
      "cluster_template": {
        "description": "The name or ID of the cluster template.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "create_timeout": {
        "description": "Timeout for creating the cluster in minutes. Set to 0 for no timeout.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "discovery_url": {
        "description": "Specifies a custom discovery url for node discovery.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "keypair": {
        "description": "The name of the keypair. If not presented, use keypair in cluster template.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "master_count": {
        "description": "The number of master nodes for this cluster.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "name": {
        "description": "The cluster name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "node_count": {
        "description": "The node count for this cluster.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "cluster_template",
      "create_timeout",
      "discovery_url",
      "keypair",
      "master_count",
      "name",
      "node_count"
    ]
  },
  "OS::Magnum::ClusterTemplate": {
    "full_properties": {
      "coe": {
        "description": "The Container Orchestration Engine for cluster.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "dns_nameserver": {
        "description": "The DNS nameserver address.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "docker_storage_driver": {
        "description": "Select a docker storage driver.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "docker_volume_size": {
        "description": "The size in GB of the docker volume.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "external_network": {
        "description": "The external neutron network name or UUID to attach the Cluster.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "fixed_network": {
        "description": "The fixed neutron network name or UUID to attach the Cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "fixed_subnet": {
        "description": "The fixed neutron subnet name or UUID to attach the Cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "flavor": {
        "description": "The nova flavor name or UUID to use when launching the cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "floating_ip_enabled": {
        "description": "Indicates whether created clusters should have a floating ip or not.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "http_proxy": {
        "description": "The http_proxy address to use for nodes in cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "https_proxy": {
        "description": "The https_proxy address to use for nodes in cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "image": {
        "description": "The image name or UUID to use as a base image for cluster.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "keypair": {
        "description": "The name of the SSH keypair to load into the cluster nodes.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "labels": {
        "description": "Arbitrary labels in the form of key=value pairs to associate with cluster.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "master_flavor": {
        "description": "The nova flavor name or UUID to use when launching the master node of the cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "master_lb_enabled": {
        "description": "Indicates whether created clusters should have a load balancer for master nodes or not.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "name": {
        "description": "The cluster template name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "network_driver": {
        "description": "The name of the driver used for instantiating container networks. By default, Magnum will choose the pre-configured network driver based on COE type.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "no_proxy": {
        "description": "A comma separated list of addresses for which proxies should not be used in the cluster.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "public": {
        "description": "Make the cluster template public. To enable this option, you must own the right to publish in magnum. Which default set to admin only.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "registry_enabled": {
        "description": "Enable the docker registry in the cluster.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "server_type": {
        "description": "Specify the server type to be used.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "tls_disabled": {
        "description": "Disable TLS in the cluster.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "volume_driver": {
        "description": "The volume driver name for instantiating container volume.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "coe",
      "dns_nameserver",
      "docker_storage_driver",
      "docker_volume_size",
      "external_network",
      "fixed_network",
      "fixed_subnet",
      "flavor",
      "floating_ip_enabled",
      "http_proxy",
      "https_proxy",
      "image",
      "keypair",
      "labels",
      "master_flavor",
      "master_lb_enabled",
      "name",
      "network_driver",
      "no_proxy",
      "public",
      "registry_enabled",
      "server_type",
      "tls_disabled",
      "volume_driver"
    ]
  },
  "OS::Manila::SecurityService": {
    "full_properties": {
      "description": {
        "description": "Security service description.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "dns_ip": {
        "description": "DNS IP address used inside tenant’s network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "domain": {
        "description": "Security service domain.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Security service name.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "password": {
        "description": "Password used by user.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "server": {
        "description": "Security service IP address or hostname.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "type": {
        "description": "Security service type.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "user": {
        "description": "Security service user or group used by tenant.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "dns_ip",
      "domain",
      "name",
      "password",
      "server",
      "type",
      "user"
    ]
  },
  "OS::Manila::Share": {
    "full_properties": {
      "access_rules": {
        "description": "A list of access rules that define access from IP to Share.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "description": {
        "description": "Share description.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "is_public": {
        "description": "Defines if shared filesystem is public or private.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "metadata": {
        "description": "Metadata key-values defined for share.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Share name.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "share_network": {
        "description": "Name or ID of shared network defined for shared filesystem.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "share_protocol": {
        "description": "Share protocol supported by shared filesystem.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "share_type": {
        "description": "Name or ID of shared filesystem type. Types defines some share filesystem profiles that will be used for share creation.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "size": {
        "description": "Share storage size in GB.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "snapshot": {
        "description": "Name or ID of shared file system snapshot that will be restored and created as a new share.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "access_rules",
      "description",
      "is_public",
      "metadata",
      "name",
      "share_network",
      "share_protocol",
      "share_type",
      "size",
      "snapshot"
    ]
  },
  "OS::Manila::ShareNetwork": {
    "full_properties": {
      "description": {
        "description": "Share network description.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the share network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "neutron_network": {
        "description": "Neutron network id.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "neutron_subnet": {
        "description": "Neutron subnet id.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "nova_network": {
        "description": "Nova network id.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "security_services": {
        "description": "A list of security services IDs or names.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "name",
      "neutron_network",
      "neutron_subnet",
      "nova_network",
      "security_services"
    ]
  },
  "OS::Manila::ShareType": {
    "full_properties": {
      "driver_handles_share_servers": {
        "description": "Required extra specification. Defines if share drivers handles share servers.",
        "required": true,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "extra_specs": {
        "description": "Extra specs key-value pairs defined for share type.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "is_public": {
        "description": "Defines if share type is accessible to the public.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the share type.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "snapshot_support": {
        "description": "Boolean extra spec that used for filtering of backends by their capability to create share snapshots.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "driver_handles_share_servers",
      "extra_specs",
      "is_public",
      "name",
      "snapshot_support"
    ]
  },
  "OS::Mistral::CronTrigger": {
    "full_properties": {
      "count": {
        "description": "Remaining executions.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "first_time": {
        "description": "Time of the first execution in format “YYYY-MM-DD HH:MM”.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the cron trigger.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "pattern": {
        "description": "Cron expression.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "workflow": {
        "description": "Workflow to execute.",
        "required": true,
        "type": "map",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "count",
      "first_time",
      "name",
      "pattern",
      "workflow"
    ]
  },
  "OS::Mistral::ExternalResource": {
    "full_properties": {
      "actions": {
        "description": "Resource action which triggers a workflow execution.",
        "required": true,
        "type": "map",
        "update_causes": "replacement"
      },
      "always_update": {
        "description": "Triggers UPDATE action execution even if input is unchanged.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "description": {
        "description": "Workflow execution description.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "input": {
        "description": "Dictionary which contains input for the workflows.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "replace_on_change_inputs": {
        "description": "A list of inputs that should cause the resource to be replaced when their values change.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "actions",
      "always_update",
      "description",
      "input",
      "replace_on_change_inputs"
    ]
  },
  "OS::Mistral::Workflow": {
    "full_properties": {
      "description": {
        "description": "Workflow description.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "input": {
        "description": "Dictionary which contains input for workflow.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Workflow name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "output": {
        "description": "Any data structure arbitrarily containing YAQL expressions that defines workflow output. May be nested.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "params": {
        "description": "Workflow additional parameters. If Workflow is reverse typed, params requires ‘task_name’, which defines initial task.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "tags": {
        "description": "List of tags to set on the workflow.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "task_defaults": {
        "description": "Default settings for some of task attributes defined at workflow level.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "tasks": {
        "description": "Dictionary containing workflow tasks.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "type": {
        "description": "Workflow type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "use_request_body_as_input": {
        "description": "Defines the method in which the request body for signaling a workflow would be parsed. In case this property is set to True, the body would be parsed as a simple json where each key is a workflow input, in other cases body would be parsed expecting a specific json format with two keys: “input” and “params”.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "input",
      "name",
      "output",
      "params",
      "tags",
      "task_defaults",
      "tasks",
      "type",
      "use_request_body_as_input"
    ]
  },
  "OS::Monasca::AlarmDefinition": {
    "full_properties": {
      "actions_enabled": {
        "description": "Whether to enable the actions or not.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "alarm_actions": {
        "description": "The notification methods to use when an alarm state is ALARM.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "expression": {
        "description": "Expression of the alarm to evaluate.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "match_by": {
        "description": "The metric dimensions to match to the alarm dimensions. One or more dimension key names separated by a comma.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the alarm. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "ok_actions": {
        "description": "The notification methods to use when an alarm state is OK.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "severity": {
        "description": "Severity of the alarm.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "undetermined_actions": {
        "description": "The notification methods to use when an alarm state is UNDETERMINED.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "actions_enabled",
      "alarm_actions",
      "description",
      "expression",
      "match_by",
      "name",
      "ok_actions",
      "severity",
      "undetermined_actions"
    ]
  },
  "OS::Monasca::Notification": {
    "full_properties": {
      "address": {
        "description": "Address of the notification. It could be a valid email address, url or service key based on notification type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the notification. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "period": {
        "description": "Interval in seconds to invoke webhooks if the alarm state does not transition away from the defined trigger state. A value of 0 will disable continuous notifications. This property is only applicable for the webhook notification type and has default period interval of 60 seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "type": {
        "description": "Type of the notification.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "address",
      "name",
      "period",
      "type"
    ]
  },
  "OS::Neutron::AddressScope": {
    "full_properties": {
      "ip_version": {
        "description": "Address family of the address scope, which is 4 or 6.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "name": {
        "description": "The name for the address scope.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether the address scope should be shared to other tenants. Note that the default policy setting restricts usage of this attribute to administrative users only, and restricts changing of shared address scope to unshared with update.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The owner tenant ID of the address scope. Only administrative users can specify a tenant ID other than their own.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "ip_version",
      "name",
      "shared",
      "tenant_id"
    ]
  },
  "OS::Neutron::Firewall": {
    "full_properties": {
      "admin_state_up": {
        "description": "Administrative state of the firewall. If false (down), firewall does not forward packets and will drop all traffic to/from VMs behind the firewall.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the firewall.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "firewall_policy_id": {
        "description": "The ID of the firewall policy that this firewall is associated with.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the firewall.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this firewall should be shared across all tenants. NOTE: The default policy setting in Neutron restricts usage of this property to administrative users only.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "value_specs": {
        "description": "Extra parameters to include in the request. Parameters are often specific to installed hardware or extensions.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "firewall_policy_id",
      "name",
      "shared",
      "value_specs"
    ]
  },
  "OS::Neutron::FirewallPolicy": {
    "full_properties": {
      "audited": {
        "description": "Whether this policy should be audited. When set to True, each time the firewall policy or the associated firewall rules are changed, this attribute will be set to False and will have to be explicitly set to True through an update operation.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the firewall policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "firewall_rules": {
        "description": "An ordered list of firewall rules to apply to the firewall.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the firewall policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this policy should be shared across all tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      }
    },
    "properties": [
      "audited",
      "description",
      "firewall_rules",
      "name",
      "shared"
    ]
  },
  "OS::Neutron::FirewallRule": {
    "full_properties": {
      "action": {
        "description": "Action to be performed on the traffic matching the rule.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the firewall rule.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "destination_ip_address": {
        "description": "Destination IP address or CIDR.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "destination_port": {
        "description": "Destination port number or a range.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "enabled": {
        "description": "Whether this rule should be enabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "ip_version": {
        "description": "Internet protocol version.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the firewall rule.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "protocol": {
        "description": "Protocol for the firewall rule.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this rule should be shared across all tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "source_ip_address": {
        "description": "Source IP address or CIDR.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "source_port": {
        "description": "Source port number or a range.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "action",
      "description",
      "destination_ip_address",
      "destination_port",
      "enabled",
      "ip_version",
      "name",
      "protocol",
      "shared",
      "source_ip_address",
      "source_port"
    ]
  },
  "OS::Neutron::FloatingIP": {
    "full_properties": {
      "dns_domain": {
        "description": "DNS domain associated with floating ip.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "dns_name": {
        "description": "DNS name associated with floating ip.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "fixed_ip_address": {
        "description": "IP address to use if the port has multiple addresses.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "floating_ip_address": {
        "description": "IP address of the floating IP. NOTE: The default policy setting in Neutron restricts usage of this property to administrative users only.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "floating_network": {
        "description": "Network to allocate floating IP from.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "floating_subnet": {
        "description": "Subnet to allocate floating IP from.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "port_id": {
        "description": "ID of an existing port with at least one IP address to associate with this floating IP.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "value_specs": {
        "description": "Extra parameters to include in the “floatingip” object in the creation request. Parameters are often specific to installed hardware or extensions.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "dns_domain",
      "dns_name",
      "fixed_ip_address",
      "floating_ip_address",
      "floating_network",
      "floating_subnet",
      "port_id",
      "value_specs"
    ]
  },
  "OS::Neutron::FloatingIPAssociation": {
    "full_properties": {
      "fixed_ip_address": {
        "description": "IP address to use if the port has multiple addresses.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "floatingip_id": {
        "description": "ID of the floating IP to associate.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "port_id": {
        "description": "ID of an existing port with at least one IP address to associate with this floating IP.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "fixed_ip_address",
      "floatingip_id",
      "port_id"
    ]
  },
  "OS::Neutron::IKEPolicy": {
    "full_properties": {
      "auth_algorithm": {
        "description": "Authentication hash algorithm for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "encryption_algorithm": {
        "description": "Encryption algorithm for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "ike_version": {
        "description": "Version for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "lifetime": {
        "description": "Safety assessment lifetime configuration for the ike policy.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "pfs": {
        "description": "Perfect forward secrecy in lowercase for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "phase1_negotiation_mode": {
        "description": "Negotiation mode for the ike policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "auth_algorithm",
      "description",
      "encryption_algorithm",
      "ike_version",
      "lifetime",
      "name",
      "pfs",
      "phase1_negotiation_mode"
    ]
  },
  "OS::Neutron::IPsecPolicy": {
    "full_properties": {
      "auth_algorithm": {
        "description": "Authentication hash algorithm for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "description": {
        "description": "Description for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "encapsulation_mode": {
        "description": "Encapsulation mode for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "encryption_algorithm": {
        "description": "Encryption algorithm for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "lifetime": {
        "description": "Safety assessment lifetime configuration for the ipsec policy.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "pfs": {
        "description": "Perfect forward secrecy for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "transform_protocol": {
        "description": "Transform protocol for the ipsec policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "auth_algorithm",
      "description",
      "encapsulation_mode",
      "encryption_algorithm",
      "lifetime",
      "name",
      "pfs",
      "transform_protocol"
    ]
  },
  "OS::Neutron::IPsecSiteConnection": {
    "full_properties": {
      "admin_state_up": {
        "description": "Administrative state for the ipsec site connection.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the ipsec site connection.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "dpd": {
        "description": "Dead Peer Detection protocol configuration for the ipsec site connection.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "ikepolicy_id": {
        "description": "Unique identifier for the ike policy associated with the ipsec site connection.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "initiator": {
        "description": "Initiator state in lowercase for the ipsec site connection.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "ipsecpolicy_id": {
        "description": "Unique identifier for the ipsec policy associated with the ipsec site connection.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "mtu": {
        "description": "Maximum transmission unit size (in bytes) for the ipsec site connection.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name for the ipsec site connection.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "peer_address": {
        "description": "Remote branch router public IPv4 address or IPv6 address or FQDN.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "peer_cidrs": {
        "description": "Remote subnet(s) in CIDR format.",
        "required": true,
        "type": "list",
        "update_causes": "replacement"
      },
      "peer_id": {
        "description": "Remote branch router identity.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "psk": {
        "description": "Pre-shared key string for the ipsec site connection.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "vpnservice_id": {
        "description": "Unique identifier for the vpn service associated with the ipsec site connection.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "dpd",
      "ikepolicy_id",
      "initiator",
      "ipsecpolicy_id",
      "mtu",
      "name",
      "peer_address",
      "peer_cidrs",
      "peer_id",
      "psk",
      "vpnservice_id"
    ]
  },
  "OS::Neutron::LBaaS::HealthMonitor": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of the health monitor.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "delay": {
        "description": "The minimum time in milliseconds between regular connections of the member.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "expected_codes": {
        "description": "The HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: a single value, such as 200. a list, such as 200, 202. a range, such as 200-204.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "http_method": {
        "description": "The HTTP method used for requests by the monitor of type HTTP.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "max_retries": {
        "description": "Number of permissible connection failures before changing the member status to INACTIVE.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "pool": {
        "description": "ID or name of the load balancing pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "ID of the tenant who owns the health monitor.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "timeout": {
        "description": "Maximum number of milliseconds for a monitor to wait for a connection to be established before it times out.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "type": {
        "description": "One of predefined health monitor types.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "url_path": {
        "description": "The HTTP path used in the HTTP request used by the monitor to test a member health. A valid value is a string the begins with a forward slash (/).",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "delay",
      "expected_codes",
      "http_method",
      "max_retries",
      "pool",
      "tenant_id",
      "timeout",
      "type",
      "url_path"
    ]
  },
  "OS::Neutron::LBaaS::L7Policy": {
    "full_properties": {
      "action": {
        "description": "Action type of the policy.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "admin_state_up": {
        "description": "The administrative state of the policy.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "listener": {
        "description": "ID or name of the listener this policy belongs to.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "position": {
        "description": "L7 policy position in ordered policies list. This must be an integer starting from 1. If not specified, policy will be placed at the tail of existing policies list.",
        "required": false,
        "type": "number",
        "update_causes": "none"
      },
      "redirect_pool": {
        "description": "ID or name of the pool for REDIRECT_TO_POOL action type.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "redirect_url": {
        "description": "URL for REDIRECT_TO_URL action type. This should be a valid URL string.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "action",
      "admin_state_up",
      "description",
      "listener",
      "name",
      "position",
      "redirect_pool",
      "redirect_url"
    ]
  },
  "OS::Neutron::LBaaS::L7Rule": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of the rule.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "compare_type": {
        "description": "Rule compare type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "invert": {
        "description": "Invert the compare type.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "key": {
        "description": "Key to compare. Relevant for HEADER and COOKIE types only.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "l7policy": {
        "description": "ID or name of L7 policy this rule belongs to.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "type": {
        "description": "Rule type.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "value": {
        "description": "Value to compare.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "compare_type",
      "invert",
      "key",
      "l7policy",
      "type",
      "value"
    ]
  },
  "OS::Neutron::LBaaS::Listener": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this listener.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "connection_limit": {
        "description": "The maximum number of connections permitted for this load balancer. Defaults to -1, which is infinite.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "default_pool": {
        "description": "ID or name of the default pool for the listener. Requires shared_pools service extension.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "default_tls_container_ref": {
        "description": "Default TLS container reference to retrieve TLS information.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this listener.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "loadbalancer": {
        "description": "ID or name of the load balancer with which listener is associated.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of this listener.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "protocol": {
        "description": "Protocol on which to listen for the client traffic.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "protocol_port": {
        "description": "TCP or UDP port on which to listen for client traffic.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "sni_container_refs": {
        "description": "List of TLS container references for SNI.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the listener.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "connection_limit",
      "default_pool",
      "default_tls_container_ref",
      "description",
      "loadbalancer",
      "name",
      "protocol",
      "protocol_port",
      "sni_container_refs",
      "tenant_id"
    ]
  },
  "OS::Neutron::LBaaS::LoadBalancer": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this Load Balancer.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "provider": {
        "description": "Provider for this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the Load Balancer. Only administrative users can specify a tenant ID other than their own.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "vip_address": {
        "description": "IP address for the VIP.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "vip_subnet": {
        "description": "The name or ID of the subnet on which to allocate the VIP address.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "name",
      "provider",
      "tenant_id",
      "vip_address",
      "vip_subnet"
    ]
  },
  "OS::Neutron::LBaaS::Pool": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this pool.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "lb_algorithm": {
        "description": "The algorithm used to distribute load between the members of the pool.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "listener": {
        "description": "Listener name or ID to be associated with this pool.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "loadbalancer": {
        "description": "Loadbalancer name or ID to be associated with this pool. Requires shared_pools service extension.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of this pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "protocol": {
        "description": "Protocol of the pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "session_persistence": {
        "description": "Configuration of session persistence.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "lb_algorithm",
      "listener",
      "loadbalancer",
      "name",
      "protocol",
      "session_persistence"
    ]
  },
  "OS::Neutron::LBaaS::PoolMember": {
    "full_properties": {
      "address": {
        "description": "IP address of the pool member on the pool network.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "admin_state_up": {
        "description": "The administrative state of the pool member.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "pool": {
        "description": "Name or ID of the load balancing pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "protocol_port": {
        "description": "Port on which the pool member listens for requests or connections.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "subnet": {
        "description": "Subnet name or ID of this member.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "weight": {
        "description": "Weight of pool member in the pool (default to 1).",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "address",
      "admin_state_up",
      "pool",
      "protocol_port",
      "subnet",
      "weight"
    ]
  },
  "OS::Neutron::MeteringLabel": {
    "full_properties": {
      "description": {
        "description": "Description of the metering label.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the metering label.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "shared": {
        "description": "Whether the metering label should be shared across all tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "name",
      "shared"
    ]
  },
  "OS::Neutron::MeteringRule": {
    "full_properties": {
      "direction": {
        "description": "The direction in which metering rule is applied, either ingress or egress.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "excluded": {
        "description": "Specify whether the remote_ip_prefix will be excluded or not from traffic counters of the metering label. For example to not count the traffic of a specific IP address of a range.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "metering_label_id": {
        "description": "The metering label ID to associate with this metering rule.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "remote_ip_prefix": {
        "description": "Indicates remote IP prefix to be associated with this metering rule.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "direction",
      "excluded",
      "metering_label_id",
      "remote_ip_prefix"
    ]
  },
  "OS::Neutron::Net": {
    "full_properties": {
      "admin_state_up": {
        "description": "A boolean value specifying the administrative status of the network.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "dhcp_agent_ids": {
        "description": "The IDs of the DHCP agent to schedule the network. Note that the default policy setting in Neutron restricts usage of this property to administrative users only.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "dns_domain": {
        "description": "DNS domain associated with this network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "A string specifying a symbolic name for the network, which is not required to be unique.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "port_security_enabled": {
        "description": "Flag to enable/disable port security on the network. It provides the default value for the attribute of the ports created on this network.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "qos_policy": {
        "description": "The name or ID of QoS policy to attach to this network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this network should be shared across all tenants. Note that the default policy setting restricts usage of this attribute to administrative users only.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "tags": {
        "description": "The tags to be added to the network.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The ID of the tenant which will own the network. Only administrative users can set the tenant identifier; this cannot be changed using authorization policies.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "value_specs": {
        "description": "Extra parameters to include in the request. Parameters are often specific to installed hardware or extensions.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "dhcp_agent_ids",
      "dns_domain",
      "name",
      "port_security_enabled",
      "qos_policy",
      "shared",
      "tags",
      "tenant_id",
      "value_specs"
    ]
  },
  "OS::Neutron::NetworkGateway": {
    "full_properties": {
      "connections": {
        "description": "Connection info for this network gateway.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "devices": {
        "description": "Device info for this network gateway.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "The name of the network gateway.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "connections",
      "devices",
      "name"
    ]
  },
  "OS::Neutron::Port": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this port.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "allowed_address_pairs": {
        "description": "Additional MAC/IP address pairs allowed to pass through the port.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "binding:vnic_type": {
        "description": "The vnic type to be bound on the neutron port. To support SR-IOV PCI passthrough networking, you can request that the neutron port to be realized as normal (virtual nic), direct (pci passthrough), or macvtap (virtual interface with a tap-like software interface). Note that this only works for Neutron deployments that support the bindings extension.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "device_id": {
        "description": "Device ID of this port.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "device_owner": {
        "description": "Name of the network owning the port. The value is typically network:floatingip or network:router_interface or network:dhcp.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "dns_name": {
        "description": "DNS name associated with the port.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "fixed_ips": {
        "description": "Desired IPs for this port.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "mac_address": {
        "description": "MAC address to give to this port. The default update policy of this property in neutron is that allow admin role only.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "A symbolic name for this port.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "network": {
        "description": "Network this port belongs to. If you plan to use current port to assign Floating IP, you should specify fixed_ips with subnet. Note if this changes to a different network update, the port will be replaced.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "port_security_enabled": {
        "description": "Flag to enable/disable port security on the port. When disable this feature(set it to False), there will be no packages filtering, like security-group and address-pairs.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "qos_policy": {
        "description": "The name or ID of QoS policy to attach to this port.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "security_groups": {
        "description": "Security group IDs to associate with this port.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tags": {
        "description": "The tags to be added to the port.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "value_specs": {
        "description": "Extra parameters to include in the request.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "allowed_address_pairs",
      "binding:vnic_type",
      "device_id",
      "device_owner",
      "dns_name",
      "fixed_ips",
      "mac_address",
      "name",
      "network",
      "port_security_enabled",
      "qos_policy",
      "security_groups",
      "tags",
      "value_specs"
    ]
  },
  "OS::Neutron::ProviderNet": {
    "full_properties": {
      "admin_state_up": {
        "description": "A boolean value specifying the administrative status of the network.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "name": {
        "description": "A string specifying a symbolic name for the network, which is not required to be unique.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "network_type": {
        "description": "A string specifying the provider network type for the network.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "physical_network": {
        "description": "A string specifying physical network mapping for the network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "port_security_enabled": {
        "description": "Flag to enable/disable port security on the network. It provides the default value for the attribute of the ports created on this network.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "router_external": {
        "description": "Whether the network contains an external router.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "segmentation_id": {
        "description": "A string specifying the segmentation id for the network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this network should be shared across all tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "name",
      "network_type",
      "physical_network",
      "port_security_enabled",
      "router_external",
      "segmentation_id",
      "shared"
    ]
  },
  "OS::Neutron::QoSBandwidthLimitRule": {
    "full_properties": {
      "max_burst_kbps": {
        "description": "Max burst bandwidth in kbps.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "max_kbps": {
        "description": "Max bandwidth in kbps.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "policy": {
        "description": "ID or name of the QoS policy.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "The owner tenant ID of this rule.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "max_burst_kbps",
      "max_kbps",
      "policy",
      "tenant_id"
    ]
  },
  "OS::Neutron::QoSDscpMarkingRule": {
    "full_properties": {
      "dscp_mark": {
        "description": "DSCP mark between 0 and 56, except 2-6, 42, 44, and 50-54.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "policy": {
        "description": "ID or name of the QoS policy.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "The owner tenant ID of this rule.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "dscp_mark",
      "policy",
      "tenant_id"
    ]
  },
  "OS::Neutron::QoSPolicy": {
    "full_properties": {
      "description": {
        "description": "The description for the QoS policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "The name for the QoS policy.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether this QoS policy should be shared to other tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The owner tenant ID of this QoS policy.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "name",
      "shared",
      "tenant_id"
    ]
  },
  "OS::Neutron::Quota": {
    "full_properties": {
      "floatingip": {
        "description": "Quota for the number of floating IPs. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "network": {
        "description": "Quota for the number of networks. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "port": {
        "description": "Quota for the number of ports. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "project": {
        "description": "Name or id of the project to set the quota for.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "router": {
        "description": "Quota for the number of routers. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "security_group": {
        "description": "Quota for the number of security groups. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "security_group_rule": {
        "description": "Quota for the number of security group rules. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "subnet": {
        "description": "Quota for the number of subnets. Setting -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "floatingip",
      "network",
      "port",
      "project",
      "router",
      "security_group",
      "security_group_rule",
      "subnet"
    ]
  },
  "OS::Neutron::RBACPolicy": {
    "full_properties": {
      "action": {
        "description": "Action for the RBAC policy.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "object_id": {
        "description": "ID or name of the RBAC object.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "object_type": {
        "description": "Type of the object that RBAC policy affects.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "target_tenant": {
        "description": "ID of the tenant to which the RBAC policy will be enforced.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The owner tenant ID. Only required if the caller has an administrative role and wants to create a RBAC for another tenant.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "action",
      "object_id",
      "object_type",
      "target_tenant",
      "tenant_id"
    ]
  },
  "OS::Neutron::Router": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of the router.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "distributed": {
        "description": "Indicates whether or not to create a distributed router. NOTE: The default policy setting in Neutron restricts usage of this property to administrative users only. This property can not be used in conjunction with the L3 agent ID.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "external_gateway_info": {
        "description": "External network gateway configuration for a router.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "ha": {
        "description": "Indicates whether or not to create a highly available router. NOTE: The default policy setting in Neutron restricts usage of this property to administrative users only. And now neutron do not support distributed and ha at the same time.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "l3_agent_ids": {
        "description": "ID list of the L3 agent. User can specify multi-agents for highly available router. NOTE: The default policy setting in Neutron restricts usage of this property to administrative users only.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "The name of the router.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "tags": {
        "description": "The tags to be added to the router.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "value_specs": {
        "description": "Extra parameters to include in the creation request.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "distributed",
      "external_gateway_info",
      "ha",
      "l3_agent_ids",
      "name",
      "tags",
      "value_specs"
    ]
  },
  "OS::Neutron::RouterInterface": {
    "full_properties": {
      "port": {
        "description": "The port, either subnet or port should be specified.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "router": {
        "description": "The router.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "subnet": {
        "description": "The subnet, either subnet or port should be specified.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "port",
      "router",
      "subnet"
    ]
  },
  "OS::Neutron::SecurityGroup": {
    "full_properties": {
      "description": {
        "description": "Description of the security group.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "A string specifying a symbolic name for the security group, which is not required to be unique.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "rules": {
        "description": "List of security group rules.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "name",
      "rules"
    ]
  },
  "OS::Neutron::SecurityGroupRule": {
    "full_properties": {
      "description": {
        "description": "Description of the security group rule.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "direction": {
        "description": "The direction in which the security group rule is applied. For a compute instance, an ingress security group rule matches traffic that is incoming (ingress) for that instance. An egress rule is applied to traffic leaving the instance.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "ethertype": {
        "description": "Ethertype of the traffic.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "port_range_max": {
        "description": "The maximum port number in the range that is matched by the security group rule. The port_range_min attribute constrains the port_range_max attribute. If the protocol is ICMP, this value must be an ICMP code.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "port_range_min": {
        "description": "The minimum port number in the range that is matched by the security group rule. If the protocol is TCP or UDP, this value must be less than or equal to the value of the port_range_max attribute. If the protocol is ICMP, this value must be an ICMP type.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "protocol": {
        "description": "The protocol that is matched by the security group rule. Allowed values are ah, dccp, egp, esp, gre, icmp, icmpv6, igmp, ipv6-encap, ipv6-frag, ipv6-icmp, ipv6-nonxt, ipv6-opts, ipv6-route, ospf, pgm, rsvp, sctp, tcp, udp, udplite, vrrp and integer representations [0-255].",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "remote_group": {
        "description": "The remote group name or ID to be associated with this security group rule.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "remote_ip_prefix": {
        "description": "The remote IP prefix (CIDR) to be associated with this security group rule.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "security_group": {
        "description": "Security group name or ID to add rule.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "direction",
      "ethertype",
      "port_range_max",
      "port_range_min",
      "protocol",
      "remote_group",
      "remote_ip_prefix",
      "security_group"
    ]
  },
  "OS::Neutron::Segment": {
    "full_properties": {
      "description": {
        "description": "Description of the segment.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the segment.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "network": {
        "description": "The name/id of network to associate with this segment.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "network_type": {
        "description": "Type of network to associate with this segment.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "physical_network": {
        "description": "Name of physical network to associate with this segment.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "segmentation_id": {
        "description": "Segmentation ID for this segment.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "description",
      "name",
      "network",
      "network_type",
      "physical_network",
      "segmentation_id"
    ]
  },
  "OS::Neutron::Subnet": {
    "full_properties": {
      "allocation_pools": {
        "description": "The start and end addresses for the allocation pools.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "cidr": {
        "description": "The CIDR.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "dns_nameservers": {
        "description": "A specified set of DNS name servers to be used.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "enable_dhcp": {
        "description": "Set to true if DHCP is enabled and false if DHCP is disabled.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "gateway_ip": {
        "description": "The gateway IP address. Set to any of [ null | ~ | “” ] to create/update a subnet without a gateway. If omitted when creation, neutron will assign the first free IP address within the subnet to the gateway automatically. If remove this from template when update, the old gateway IP address will be detached.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "host_routes": {
        "description": "A list of host route dictionaries for the subnet.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "ip_version": {
        "description": "The IP version, which is 4 or 6.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "ipv6_address_mode": {
        "description": "IPv6 address mode.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "ipv6_ra_mode": {
        "description": "IPv6 RA (Router Advertisement) mode.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "The name of the subnet.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "network": {
        "description": "The ID of the attached network.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "prefixlen": {
        "description": "Prefix length for subnet allocation from subnet pool.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "segment": {
        "description": "The name/ID of the segment to associate.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "subnetpool": {
        "description": "The name or ID of the subnet pool.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "tags": {
        "description": "The tags to be added to the subnet.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the network. Only administrative users can specify a tenant ID other than their own.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "value_specs": {
        "description": "Extra parameters to include in the request.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      }
    },
    "properties": [
      "allocation_pools",
      "cidr",
      "dns_nameservers",
      "enable_dhcp",
      "gateway_ip",
      "host_routes",
      "ip_version",
      "ipv6_address_mode",
      "ipv6_ra_mode",
      "name",
      "network",
      "prefixlen",
      "segment",
      "subnetpool",
      "tags",
      "tenant_id",
      "value_specs"
    ]
  },
  "OS::Neutron::SubnetPool": {
    "full_properties": {
      "address_scope": {
        "description": "An address scope ID to assign to the subnet pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "default_prefixlen": {
        "description": "The size of the prefix to allocate when the cidr or prefixlen attributes are not specified while creating a subnet.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "default_quota": {
        "description": "A per-tenant quota on the prefix space that can be allocated from the subnet pool for tenant subnets.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "is_default": {
        "description": "Whether this is default IPv4/IPv6 subnet pool. There can only be one default subnet pool for each IP family. Note that the default policy setting restricts administrative users to set this to True.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "max_prefixlen": {
        "description": "Maximum prefix size that can be allocated from the subnet pool.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "min_prefixlen": {
        "description": "Smallest prefix size that can be allocated from the subnet pool.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the subnet pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "prefixes": {
        "description": "List of subnet prefixes to assign.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "shared": {
        "description": "Whether the subnet pool will be shared across all tenants. Note that the default policy setting restricts usage of this attribute to administrative users only.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "tags": {
        "description": "The tags to be added to the subnetpool.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the subnet pool. Only administrative users can specify a tenant ID other than their own.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "address_scope",
      "default_prefixlen",
      "default_quota",
      "is_default",
      "max_prefixlen",
      "min_prefixlen",
      "name",
      "prefixes",
      "shared",
      "tags",
      "tenant_id"
    ]
  },
  "OS::Neutron::Trunk": {
    "full_properties": {
      "admin_state_up": {
        "description": "Enable/disable subport addition, removal and trunk delete.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the trunk.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "A string specifying a symbolic name for the trunk, which is not required to be uniqe.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "port": {
        "description": "ID or name of a port to be used as a parent port.",
        "required": true,
        "type": "string",
        "update_causes": "unknown"
      },
      "sub_ports": {
        "description": "List with 0 or more map elements containing subport details.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "name",
      "port",
      "sub_ports"
    ]
  },
  "OS::Neutron::VPNService": {
    "full_properties": {
      "admin_state_up": {
        "description": "Administrative state for the vpn service.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description for the vpn service.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the vpn service.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "router": {
        "description": "The router to which the vpn service will be inserted.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "subnet": {
        "description": "Subnet in which the vpn service will be created.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "name",
      "router",
      "subnet"
    ]
  },
  "OS::Nova::Flavor": {
    "full_properties": {
      "disk": {
        "description": "Size of local disk in GB. The “0” size is a special case that uses the native base image size as the size of the ephemeral root volume.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "ephemeral": {
        "description": "Size of a secondary ephemeral data disk in GB.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "extra_specs": {
        "description": "Key/Value pairs to extend the capabilities of the flavor.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "flavorid": {
        "description": "Unique ID of the flavor. If not specified, an UUID will be auto generated and used.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "is_public": {
        "description": "Scope of flavor accessibility. Public or private. Default value is True, means public, shared across all projects.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the flavor.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "ram": {
        "description": "Memory in MB for the flavor.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "rxtx_factor": {
        "description": "RX/TX factor.",
        "required": false,
        "type": "number",
        "update_causes": "replacement"
      },
      "swap": {
        "description": "Swap space in MB.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "tenants": {
        "description": "List of tenants.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "vcpus": {
        "description": "Number of VCPUs for the flavor.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "disk",
      "ephemeral",
      "extra_specs",
      "flavorid",
      "is_public",
      "name",
      "ram",
      "rxtx_factor",
      "swap",
      "tenants",
      "vcpus"
    ]
  },
  "OS::Nova::HostAggregate": {
    "full_properties": {
      "availability_zone": {
        "description": "Name for the availability zone.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "hosts": {
        "description": "List of hosts to join aggregate.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "metadata": {
        "description": "Arbitrary key/value metadata to store information for aggregate.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the aggregate.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "availability_zone",
      "hosts",
      "metadata",
      "name"
    ]
  },
  "OS::Nova::KeyPair": {
    "full_properties": {
      "name": {
        "description": "The name of the key pair.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "public_key": {
        "description": "The optional public key. This allows users to supply the public key from a pre-existing key pair. If not supplied, a new key pair will be generated.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "save_private_key": {
        "description": "True if the system should remember a generated private key; False otherwise.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "type": {
        "description": "Keypair type. Supported since Nova api version 2.2.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "user": {
        "description": "ID or name of user to whom to add key-pair. The usage of this property is limited to being used by administrators only. Supported since Nova api version 2.10.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "name",
      "public_key",
      "save_private_key",
      "type",
      "user"
    ]
  },
  "OS::Nova::Quota": {
    "full_properties": {
      "cores": {
        "description": "Quota for the number of cores. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "fixed_ips": {
        "description": "Quota for the number of fixed IPs. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "floating_ips": {
        "description": "Quota for the number of floating IPs. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "injected_file_content_bytes": {
        "description": "Quota for the number of injected file content bytes. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "injected_file_path_bytes": {
        "description": "Quota for the number of injected file path bytes. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "injected_files": {
        "description": "Quota for the number of injected files. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "instances": {
        "description": "Quota for the number of instances. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "key_pairs": {
        "description": "Quota for the number of key pairs. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "metadata_items": {
        "description": "Quota for the number of metadata items. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "project": {
        "description": "Name or id of the project to set the quota for.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "ram": {
        "description": "Quota for the amount of ram (in megabytes). Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "security_group_rules": {
        "description": "Quota for the number of security group rules. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "security_groups": {
        "description": "Quota for the number of security groups. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "server_group_members": {
        "description": "Quota for the number of server group members. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "server_groups": {
        "description": "Quota for the number of server groups. Setting the value to -1 removes the limit.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "cores",
      "fixed_ips",
      "floating_ips",
      "injected_file_content_bytes",
      "injected_file_path_bytes",
      "injected_files",
      "instances",
      "key_pairs",
      "metadata_items",
      "project",
      "ram",
      "security_group_rules",
      "security_groups",
      "server_group_members",
      "server_groups"
    ]
  },
  "OS::Nova::Server": {
    "full_properties": {
      "admin_pass": {
        "description": "The administrator password for the server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "availability_zone": {
        "description": "Name of the availability zone for server placement.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "block_device_mapping": {
        "description": "Block device mappings for this server.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "block_device_mapping_v2": {
        "description": "Block device mappings v2 for this server.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "config_drive": {
        "description": "If True, enable config drive on the server.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "deployment_swift_data": {
        "description": "Swift container and object to use for storing deployment data for the server resource. The parameter is a map value with the keys “container” and “object”, and the values are the corresponding container and object names. The software_config_transport parameter must be set to POLL_TEMP_URL for swift to be used. If not specified, and software_config_transport is set to POLL_TEMP_URL, a container will be automatically created from the resource name, and the object name will be a generated uuid.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "diskConfig": {
        "description": "Control how the disk is partitioned when the server is created.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "flavor": {
        "description": "The ID or name of the flavor to boot onto.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "flavor_update_policy": {
        "description": "Policy on how to apply a flavor update; either by requesting a server resize or by replacing the entire server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "image": {
        "description": "The ID or name of the image to boot with.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "image_update_policy": {
        "description": "Policy on how to apply an image-id update; either by requesting a server rebuild or by replacing the entire server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "key_name": {
        "description": "Name of keypair to inject into the server.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "metadata": {
        "description": "Arbitrary key/value metadata to store for this server. Both keys and values must be 255 characters or less. Non-string values will be serialized to JSON (and the serialized string must be 255 characters or less).",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Server name.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "networks": {
        "description": "An ordered list of nics to be added to this server, with information about connected networks, fixed ips, port etc.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "personality": {
        "description": "A map of files to create/overwrite on the server upon boot. Keys are file names and values are the file contents.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "reservation_id": {
        "description": "A UUID for the set of servers being requested.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "scheduler_hints": {
        "description": "Arbitrary key-value pairs specified by the client to help boot a server.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "security_groups": {
        "description": "List of security group names or IDs. Cannot be used if neutron ports are associated with this server; assign security groups to the ports instead.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "software_config_transport": {
        "description": "How the server should receive the metadata required for software configuration. POLL_SERVER_CFN will allow calls to the cfn API action DescribeStackResource authenticated with the provided keypair. POLL_SERVER_HEAT will allow calls to the Heat API resource-show using the provided keystone credentials. POLL_TEMP_URL will create and populate a Swift TempURL with metadata for polling. ZAQAR_MESSAGE will create a dedicated zaqar queue and post the metadata for polling.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "tags": {
        "description": "Server tags. Supported since client version 2.26.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "user_data": {
        "description": "User data script to be executed by cloud-init. Changes cause replacement of the resource by default, but can be ignored altogether by setting the `user_data_update_policy` property.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "user_data_format": {
        "description": "How the user_data should be formatted for the server. For HEAT_CFNTOOLS, the user_data is bundled as part of the heat-cfntools cloud-init boot configuration data. For RAW the user_data is passed to Nova unmodified. For SOFTWARE_CONFIG user_data is bundled as part of the software config data, and metadata is derived from any associated SoftwareDeployment resources.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "user_data_update_policy": {
        "description": "Policy on how to apply a user_data update; either by ignoring it or by replacing the entire server.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_pass",
      "availability_zone",
      "block_device_mapping",
      "block_device_mapping_v2",
      "config_drive",
      "deployment_swift_data",
      "diskConfig",
      "flavor",
      "flavor_update_policy",
      "image",
      "image_update_policy",
      "key_name",
      "metadata",
      "name",
      "networks",
      "personality",
      "reservation_id",
      "scheduler_hints",
      "security_groups",
      "software_config_transport",
      "tags",
      "user_data",
      "user_data_format",
      "user_data_update_policy"
    ]
  },
  "OS::Nova::ServerGroup": {
    "full_properties": {
      "name": {
        "description": "Server Group name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "policies": {
        "description": "A list of string policies to apply. Defaults to anti-affinity.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "name",
      "policies"
    ]
  },
  "OS::Octavia::HealthMonitor": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of the health monitor.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "delay": {
        "description": "The minimum time in milliseconds between regular connections of the member.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "expected_codes": {
        "description": "The HTTP status codes expected in response from the member to declare it healthy. Specify one of the following values: a single value, such as 200. a list, such as 200, 202. a range, such as 200-204.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "http_method": {
        "description": "The HTTP method used for requests by the monitor of type HTTP.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "max_retries": {
        "description": "Number of permissible connection failures before changing the member status to INACTIVE.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "pool": {
        "description": "ID or name of the load balancing pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "ID of the tenant who owns the health monitor.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "timeout": {
        "description": "Maximum number of milliseconds for a monitor to wait for a connection to be established before it times out.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "type": {
        "description": "One of predefined health monitor types.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "url_path": {
        "description": "The HTTP path used in the HTTP request used by the monitor to test a member health. A valid value is a string the begins with a forward slash (/).",
        "required": false,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "admin_state_up",
      "delay",
      "expected_codes",
      "http_method",
      "max_retries",
      "pool",
      "tenant_id",
      "timeout",
      "type",
      "url_path"
    ]
  },
  "OS::Octavia::Listener": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this listener.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "connection_limit": {
        "description": "The maximum number of connections permitted for this load balancer. Defaults to -1, which is infinite.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "default_pool": {
        "description": "ID or name of the default pool for the listener. Requires shared_pools service extension.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "default_tls_container_ref": {
        "description": "Default TLS container reference to retrieve TLS information.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this listener.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "loadbalancer": {
        "description": "ID or name of the load balancer with which listener is associated.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of this listener.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "protocol": {
        "description": "Protocol on which to listen for the client traffic.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "protocol_port": {
        "description": "TCP or UDP port on which to listen for client traffic.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "sni_container_refs": {
        "description": "List of TLS container references for SNI.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the listener.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "connection_limit",
      "default_pool",
      "default_tls_container_ref",
      "description",
      "loadbalancer",
      "name",
      "protocol",
      "protocol_port",
      "sni_container_refs",
      "tenant_id"
    ]
  },
  "OS::Octavia::LoadBalancer": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this Load Balancer.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "provider": {
        "description": "Provider for this Load Balancer.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "tenant_id": {
        "description": "The ID of the tenant who owns the Load Balancer. Only administrative users can specify a tenant ID other than their own.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "vip_address": {
        "description": "IP address for the VIP.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "vip_subnet": {
        "description": "The name or ID of the subnet on which to allocate the VIP address.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "name",
      "provider",
      "tenant_id",
      "vip_address",
      "vip_subnet"
    ]
  },
  "OS::Octavia::Pool": {
    "full_properties": {
      "admin_state_up": {
        "description": "The administrative state of this pool.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of this pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "lb_algorithm": {
        "description": "The algorithm used to distribute load between the members of the pool.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "listener": {
        "description": "Listener name or ID to be associated with this pool.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "loadbalancer": {
        "description": "Loadbalancer name or ID to be associated with this pool. Requires shared_pools service extension.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of this pool.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "protocol": {
        "description": "Protocol of the pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "session_persistence": {
        "description": "Configuration of session persistence.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "admin_state_up",
      "description",
      "lb_algorithm",
      "listener",
      "loadbalancer",
      "name",
      "protocol",
      "session_persistence"
    ]
  },
  "OS::Octavia::PoolMember": {
    "full_properties": {
      "address": {
        "description": "IP address of the pool member on the pool network.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "admin_state_up": {
        "description": "The administrative state of the pool member.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "monitor_address": {
        "description": "Alternate IP address which health monitor can use for health check.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "monitor_port": {
        "description": "Alternate Port which health monitor can use for health check.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "pool": {
        "description": "Name or ID of the load balancing pool.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "protocol_port": {
        "description": "Port on which the pool member listens for requests or connections.",
        "required": true,
        "type": "integer",
        "update_causes": "replacement"
      },
      "subnet": {
        "description": "Subnet name or ID of this member.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "weight": {
        "description": "Weight of pool member in the pool (default to 1).",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "address",
      "admin_state_up",
      "monitor_address",
      "monitor_port",
      "pool",
      "protocol_port",
      "subnet",
      "weight"
    ]
  },
  "OS::Sahara::Cluster": {
    "full_properties": {
      "cluster_template_id": {
        "description": "ID of the Cluster Template used for Node Groups and configurations.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "default_image_id": {
        "description": "Default name or UUID of the image used to boot Hadoop nodes.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "hadoop_version": {
        "description": "Version of Hadoop running on instances.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "key_name": {
        "description": "Keypair added to instances to make them accessible for user.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Hadoop cluster name.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "neutron_management_network": {
        "description": "Name or UUID of network.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "plugin_name": {
        "description": "Plugin name.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "shares": {
        "description": "List of manila shares to be mounted.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "use_autoconfig": {
        "description": "Configure most important configs automatically.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "cluster_template_id",
      "default_image_id",
      "hadoop_version",
      "key_name",
      "name",
      "neutron_management_network",
      "plugin_name",
      "shares",
      "use_autoconfig"
    ]
  },
  "OS::Sahara::ClusterTemplate": {
    "full_properties": {
      "anti_affinity": {
        "description": "List of processes to enable anti-affinity for.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "cluster_configs": {
        "description": "Cluster configs dictionary.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "default_image_id": {
        "description": "ID of the default image to use for the template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the Sahara Group Template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "hadoop_version": {
        "description": "Version of Hadoop running on instances.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the Sahara Cluster Template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "neutron_management_network": {
        "description": "Name or UUID of network.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "node_groups": {
        "description": "Node groups.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "plugin_name": {
        "description": "Plugin name.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "shares": {
        "description": "List of manila shares to be mounted.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "use_autoconfig": {
        "description": "Configure most important configs automatically.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "anti_affinity",
      "cluster_configs",
      "default_image_id",
      "description",
      "hadoop_version",
      "name",
      "neutron_management_network",
      "node_groups",
      "plugin_name",
      "shares",
      "use_autoconfig"
    ]
  },
  "OS::Sahara::DataSource": {
    "full_properties": {
      "credentials": {
        "description": "Credentials used for swift. Not required if sahara is configured to use proxy users and delegated trusts for access.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the data source.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the data source.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "type": {
        "description": "Type of the data source.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "url": {
        "description": "URL for the data source.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "credentials",
      "description",
      "name",
      "type",
      "url"
    ]
  },
  "OS::Sahara::ImageRegistry": {
    "full_properties": {
      "description": {
        "description": "Description of the image.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "image": {
        "description": "ID or name of the image to register.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "tags": {
        "description": "Tags to add to the image.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "username": {
        "description": "Username of privileged user in the image.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "description",
      "image",
      "tags",
      "username"
    ]
  },
  "OS::Sahara::Job": {
    "full_properties": {
      "default_execution_data": {
        "description": "Default execution data to use when run signal.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the job.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "is_protected": {
        "description": "If True, job will be protected from modifications and can not be deleted until this property is set to False.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "is_public": {
        "description": "If True, job will be shared across the tenants.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "libs": {
        "description": "IDs or names of job’s lib job binaries.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "mains": {
        "description": "IDs or names of job’s main job binary. In case of specific Sahara service, this property designed as a list, but accepts only one item.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the job.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "type": {
        "description": "Type of the job.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "default_execution_data",
      "description",
      "is_protected",
      "is_public",
      "libs",
      "mains",
      "name",
      "type"
    ]
  },
  "OS::Sahara::JobBinary": {
    "full_properties": {
      "credentials": {
        "description": "Credentials used for swift. Not required if sahara is configured to use proxy users and delegated trusts for access.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the job binary.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the job binary.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "url": {
        "description": "URL for the job binary. Must be in the format swift://<container>/<path> or internal-db://<uuid>.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "credentials",
      "description",
      "name",
      "url"
    ]
  },
  "OS::Sahara::NodeGroupTemplate": {
    "full_properties": {
      "auto_security_group": {
        "description": "Defines whether auto-assign security group to this Node Group template.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "availability_zone": {
        "description": "Availability zone to create servers in.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "description": {
        "description": "Description of the Node Group Template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "flavor": {
        "description": "Name or ID Nova flavor for the nodes.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "floating_ip_pool": {
        "description": "Name or UUID of the Neutron floating IP network or name of the Nova floating ip pool to use. Should not be provided when used with Nova-network that auto-assign floating IPs.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "hadoop_version": {
        "description": "Version of Hadoop running on instances.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "image_id": {
        "description": "ID of the image to use for the template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "is_proxy_gateway": {
        "description": "Provide access to nodes using other nodes of the cluster as proxy gateways.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "name": {
        "description": "Name for the Sahara Node Group Template.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "node_configs": {
        "description": "Dictionary of node configurations.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "node_processes": {
        "description": "List of processes to run on every node.",
        "required": true,
        "type": "list",
        "update_causes": "none"
      },
      "plugin_name": {
        "description": "Plugin name.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "security_groups": {
        "description": "List of security group names or IDs to assign to this Node Group template.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "shares": {
        "description": "List of manila shares to be mounted.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "use_autoconfig": {
        "description": "Configure most important configs automatically.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "volume_local_to_instance": {
        "description": "Create volumes on the same physical port as an instance.",
        "required": false,
        "type": "boolean",
        "update_causes": "none"
      },
      "volume_type": {
        "description": "Type of the volume to create on Cinder backend.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "volumes_availability_zone": {
        "description": "Availability zone to create volumes in.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "volumes_per_node": {
        "description": "Volumes per node.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "volumes_size": {
        "description": "Size of the volumes, in GB.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "auto_security_group",
      "availability_zone",
      "description",
      "flavor",
      "floating_ip_pool",
      "hadoop_version",
      "image_id",
      "is_proxy_gateway",
      "name",
      "node_configs",
      "node_processes",
      "plugin_name",
      "security_groups",
      "shares",
      "use_autoconfig",
      "volume_local_to_instance",
      "volume_type",
      "volumes_availability_zone",
      "volumes_per_node",
      "volumes_size"
    ]
  },
  "OS::Senlin::Cluster": {
    "full_properties": {
      "desired_capacity": {
        "description": "Desired initial number of resources in cluster.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "max_size": {
        "description": "Maximum number of resources in the cluster. -1 means unlimited.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "metadata": {
        "description": "Metadata key-values defined for cluster.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "min_size": {
        "description": "Minimum number of resources in the cluster.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the cluster. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "policies": {
        "description": "A list of policies to attach to this cluster.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "profile": {
        "description": "The name or id of the Senlin profile.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "timeout": {
        "description": "The number of seconds to wait for the cluster actions.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "desired_capacity",
      "max_size",
      "metadata",
      "min_size",
      "name",
      "policies",
      "profile",
      "timeout"
    ]
  },
  "OS::Senlin::Node": {
    "full_properties": {
      "cluster": {
        "description": "The name of senlin cluster to attach to.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "metadata": {
        "description": "Metadata key-values defined for node.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the senlin node. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "profile": {
        "description": "Name or ID of senlin profile to create this node.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "cluster",
      "metadata",
      "name",
      "profile"
    ]
  },
  "OS::Senlin::Policy": {
    "full_properties": {
      "bindings": {
        "description": "A list of clusters to which this policy is attached.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the senlin policy. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "properties": {
        "description": "Properties of this policy.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "type": {
        "description": "The type of senlin policy.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "bindings",
      "name",
      "properties",
      "type"
    ]
  },
  "OS::Senlin::Profile": {
    "full_properties": {
      "metadata": {
        "description": "Metadata key-values defined for profile.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the senlin profile. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "properties": {
        "description": "Properties for profile.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "type": {
        "description": "The type of profile.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "metadata",
      "name",
      "properties",
      "type"
    ]
  },
  "OS::Senlin::Receiver": {
    "full_properties": {
      "action": {
        "description": "The action to be executed when the receiver is signaled.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "cluster": {
        "description": "Name or ID of target cluster.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the senlin receiver. By default, physical resource name is used.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "params": {
        "description": "The parameters passed to action when the receiver is signaled.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "type": {
        "description": "Type of receiver.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "action",
      "cluster",
      "name",
      "params",
      "type"
    ]
  },
  "OS::Swift::Container": {
    "full_properties": {
      "PurgeOnDelete": {
        "description": "If True, delete any objects in the container when the container is deleted. Otherwise, deleting a non-empty container will result in an error.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name for the container. If not specified, a unique name will be generated.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "PurgeOnDelete",
      "name"
    ]
  },
  "OS::Trove::Cluster": {
    "full_properties": {
      "datastore_type": {
        "description": "Name of registered datastore type.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "datastore_version": {
        "description": "Name of the registered datastore version. It must exist for provided datastore type. Defaults to using single active version. If several active versions exist for provided datastore type, explicit value for this parameter must be specified.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "instances": {
        "description": "List of database instances.",
        "required": true,
        "type": "list",
        "update_causes": "replacement"
      },
      "name": {
        "description": "Name of the cluster to create.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "datastore_type",
      "datastore_version",
      "instances",
      "name"
    ]
  },
  "OS::Trove::Instance": {
    "full_properties": {
      "availability_zone": {
        "description": "Name of the availability zone for DB instance.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "databases": {
        "description": "List of databases to be created on DB instance creation.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      },
      "datastore_type": {
        "description": "Name of registered datastore type.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "datastore_version": {
        "description": "Name of the registered datastore version. It must exist for provided datastore type. Defaults to using single active version. If several active versions exist for provided datastore type, explicit value for this parameter must be specified.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "flavor": {
        "description": "Reference to a flavor for creating DB instance.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the DB instance to create.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "networks": {
        "description": "List of network interfaces to create on instance.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "replica_count": {
        "description": "The number of replicas to be created.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      },
      "replica_of": {
        "description": "Identifier of the source instance to replicate.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "restore_point": {
        "description": "DB instance restore point.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "size": {
        "description": "Database volume size in GB.",
        "required": true,
        "type": "integer",
        "update_causes": "none"
      },
      "users": {
        "description": "List of users to be created on DB instance creation.",
        "required": false,
        "type": "list",
        "update_causes": "none"
      }
    },
    "properties": [
      "availability_zone",
      "databases",
      "datastore_type",
      "datastore_version",
      "flavor",
      "name",
      "networks",
      "replica_count",
      "replica_of",
      "restore_point",
      "size",
      "users"
    ]
  },
  "OS::Zaqar::MistralTrigger": {
    "full_properties": {
      "input": {
        "description": "Input values to pass to the Mistral workflow.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "params": {
        "description": "Parameters to pass to the Mistral workflow execution. The parameters depend on the workflow type.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "queue_name": {
        "description": "Name of the queue to subscribe to.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "ttl": {
        "description": "Time to live of the subscription in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "workflow_id": {
        "description": "UUID of the Mistral workflow to trigger.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      }
    },
    "properties": [
      "input",
      "params",
      "queue_name",
      "ttl",
      "workflow_id"
    ]
  },
  "OS::Zaqar::Queue": {
    "full_properties": {
      "metadata": {
        "description": "Arbitrary key/value metadata to store contextual information about this queue.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the queue instance to create.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "metadata",
      "name"
    ]
  },
  "OS::Zaqar::SignedQueueURL": {
    "full_properties": {
      "methods": {
        "description": "List of allowed HTTP methods to be used. Default to allow GET.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "paths": {
        "description": "List of allowed paths to be accessed. Default to allow queue messages URL.",
        "required": false,
        "type": "list",
        "update_causes": "replacement"
      },
      "queue": {
        "description": "Name of the queue instance to create a URL for.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "ttl": {
        "description": "Time validity of the URL, in seconds. Default to one day.",
        "required": false,
        "type": "integer",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "methods",
      "paths",
      "queue",
      "ttl"
    ]
  },
  "OS::Zaqar::Subscription": {
    "full_properties": {
      "options": {
        "description": "Options used to configure this subscription.",
        "required": false,
        "type": "map",
        "update_causes": "none"
      },
      "queue_name": {
        "description": "Name of the queue to subscribe to.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "subscriber": {
        "description": "URI of the subscriber which will be notified. Must be in the format: <TYPE>:<VALUE>.",
        "required": true,
        "type": "string",
        "update_causes": "none"
      },
      "ttl": {
        "description": "Time to live of the subscription in seconds.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      }
    },
    "properties": [
      "options",
      "queue_name",
      "subscriber",
      "ttl"
    ]
  },
  "OS::Zun::Container": {
    "full_properties": {
      "command": {
        "description": "Send command to the container.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "cpu": {
        "description": "The number of virtual cpus.",
        "required": false,
        "type": "number",
        "update_causes": "none"
      },
      "environment": {
        "description": "The environment variables.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "image": {
        "description": "Name or ID of the image.",
        "required": true,
        "type": "string",
        "update_causes": "replacement"
      },
      "image_driver": {
        "description": "The image driver to use to pull container image.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "image_pull_policy": {
        "description": "The policy which determines if the image should be pulled prior to starting the container.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "interactive": {
        "description": "Keep STDIN open even if not attached.",
        "required": false,
        "type": "boolean",
        "update_causes": "replacement"
      },
      "labels": {
        "description": "Adds a map of labels to a container. May be used multiple times.",
        "required": false,
        "type": "map",
        "update_causes": "replacement"
      },
      "memory": {
        "description": "The container memory size in MiB.",
        "required": false,
        "type": "integer",
        "update_causes": "none"
      },
      "name": {
        "description": "Name of the container.",
        "required": false,
        "type": "string",
        "update_causes": "none"
      },
      "restart_policy": {
        "description": "Restart policy to apply when a container exits. Possible values are “no”, “on-failure[:max-retry]”, “always”, and “unless-stopped”.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      },
      "workdir": {
        "description": "The working directory for commands to run in.",
        "required": false,
        "type": "string",
        "update_causes": "replacement"
      }
    },
    "properties": [
      "command",
      "cpu",
      "environment",
      "image",
      "image_driver",
      "image_pull_policy",
      "interactive",
      "labels",
      "memory",
      "name",
      "restart_policy",
      "workdir"
    ]
  }
}
